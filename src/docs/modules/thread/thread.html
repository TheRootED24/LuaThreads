<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../../luadoc.css" type="text/css" />
	<!--meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/-->
</head>

<body>
<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->

<div id="main">

<div id="navigation">


<h1>LuaDoc</h1>
<ul>
	
	<li><a href="../../index.html">Index</a></li>
	
</ul>


<!-- Module list -->

<h1>Modules</h1>
<ul>

	<li>
		<a href="../threads.html">threads</a>
	</li>

	<li>
		<a href="thread.html">threads.thread</a>
	</li>

	<li>
		<a href="attr.html">threads.thread.attr</a>
	</li>

	<li>
		<a href="cond.html">threads.thread.cond</a>
	</li>

	<li>
		<a href="mutex.html">threads.thread.mutex</a>
	</li>

	<li><strong>threads.thread</strong></li>
	
</ul>



<!-- File list -->







</div><!-- id="navigation" -->

<div id="content">

<h1>Class <code>threads.thread</code></h1>

<p>
 Low-level thread creation and manipulation library.</p>


<!--

	{ "new",	thread_new	},
	{ "create",	thread_create	},
	{ "yield",	thread_yield	},
	{ "resume",	thread_resume	},
	{ "complete",	thread_complete	},
	{ "join",	thread_join	},
	{ "cancel",	thread_cancel	},

	{ "mutex",	thread_mutex,	},
	{ "sem",	thread_sem,	},

	{ "id",		thread_id	},
	{ "run", 	thread_run	},
	{ "state", 	thread_state	},
	{ "sleep",	thread_sleep	},
	{ "exit",	thread_exit	},-->	


<h2>Functions</h2>
<table class="function_list">

	<tr>
	<td class="name" nowrap><a href="#threads.thread.new">new</a>&nbsp;( to )</td>
	<td class="summary">Create a new thread object, or validate a thread object passed from a function.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#threads.thread.create">create</a>&nbsp;( to, func, to2)</td>
	<td class="summary">Create (run) a new thread.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#threads.thread.yield">yield</a>&nbsp;( to )</td>
	<td class="summary">Yield an active thread.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#threads.thread.resume">resume</a>&nbsp;( to )</td>
	<td class="summary">Resume a yielded thread.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#threads.thread.complete">complete</a>&nbsp;( to )</td>
	<td class="summary">Signal an active thread to complete and return.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#threads.thread.join">join</a>&nbsp;( to )</td>
	<td class="summary">Join a completed thread and free the resources.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#threads.thread.cancel">cancel</a>&nbsp;( to )</td>
	<td class="summary">Signal a thread to terminate and return.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#threads.thread.id">id</a>&nbsp;( to )</td>
	<td class="summary">Get a threads lua id number.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#threads.thread.run">run</a>&nbsp;( to, bool )</td>
	<td class="summary">Check threads current running state.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#threads.thread.state">state</a>&nbsp;( to )</td>
	<td class="summary">Check a threads current execution state.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#threads.thread.sleep">sleep</a>&nbsp;( sec, nsec )</td>
	<td class="summary">Force a thread to sleep.</td>
	</tr>

	<tr>
	<td class="name" nowrap><a href="#threads.threa.exit">exit</a>&nbsp;( to )</td>
	<td class="summary">Force a thread to exit without returning</td>
	</tr>

</table>

<br/>
<br/>

<h2><a name="functions"></a>Functions</h2>
<dl class="function">

<dt><a name="threads.thread.new"></a><strong>new</strong>&nbsp;( to )</dt>
<dd> Create a new thread or validate thread passed by function.


<h3>Parameters</h3>
<ul>
	<li>
	  to: Thread object (optional)
	</li>
</ul>


<h3>Usage:</h3>
<ul>
<li> Create a new thread object<br/>
<code>local t1 = thread.create()</code><br/><br/>
<li> Validate a passed thread object </li>
<code>func(nt)<br/>
&nbsp;&nbsp;&nbsp;local t = thread.new(nt)<br/><br/>
...</code>
</ul>


<h3>Return value:</h3>
a valid thread object upon success or error if passed thread is invalid or thread creation fails<br/>
</dd>


<dt><a name="threads.thread.create"></a><strong>create</strong>&nbsp;(to, func, to2)</dt>
<dd> Create and initiate a new thread.

<h3>Parameters:</h3>
<ul>
	<li>
	  to: Thread Object
	</li>
	<li>
	  func: a lua function to run (must be global)
	</li>
	<li>
	  to2: parent or partner thread. (optional)
	</li>
</ul>

<h3>Usage:</h3>
<ul>
	<li>Create a single thread<br/>
	<code>threads.thread.create(t1, "func");</code><br/><br/>
	<li>Create a single thread with access to parent/partner<br/>
	<code>threads.thread.create(t1, "func", t2);</code><br/>
</ul>

<h3>Return value:</h3>
0 if thread is created or non zero errno value if creation fails 

<h3>See also:</h3>
<ul>
	<li><a href="threads.thread.new">
		threads.thread.new
	</a>
	<li><a href="threads.thread.join">
		threads.thread.join
	</a>

</ul>
<h3>Demo</h3>
<ul>
	<li><a href="threads.thread.new">
			simple-thread-demo
	</a></li>
</ul>
</dd>


<dt><a name="threads.thread.yield"></a><strong>yield</strong>&nbsp;( to )</dt>
<dd> Yield an active thread.

<h3>Parameters</h3>
<ul>
	<li>
	  to: Thread Object
	</li>
</ul>

<h3>Usage:</h3>
<code>
	function produce( producer )<br/>
	&nbsp;&nbsp;local t = thread.new(t);<br/>
	&nbsp;&nbsp;while( thread.state(producer) == WORKING) do <br/>
	&nbsp;&nbsp;&nbsp;&nbsp;buf[#buf+1] = new_data<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;thread.yield(producer)<br/>
	&nbsp;&nbsp;end<br/><br/>


</code>


<h3>Return value:</h3>
a valid thread object upon success or error if passed thread is invalid or thread creation fails.<br/>
</dd>

<dt><a name="thread.thread.resume"></a><strong>resume</strong>&nbsp;( to )</dt>
<dd>Resume a yielded thread.

<h3>Parameters</h3>
<ul>
	<li>
	  to: Thread Object
	</li>
</ul>

<h3>Usage:</h3>
<code>
	while(need_more < complete) do<br/>
		&nbsp;&nbsp;if(thread.resume(producer) ~= 0) then<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;thread.error(consumer)<br/>
			&nbsp;&nbsp;&nbsp;&nbsp;break;<br/>
		&nbsp;&nbsp;end<br/>
	end
</code>

<h3>Return value:</h3>
0 success 1 on failure
</dd>

<dt><a name="threads.thread.complete"></a><strong>complete</strong>&nbsp;( to )</dt>
<dd> Signal a thread to complete its tasks and return.

<h3>Parameters</h3>
<ul>
	<li>
	  t: Thread Object
	</li>
</ul>

<h3>Usage:</h3>
<code>
	if(task == done) then return(thread.complete(t)) end
</code>


<h3>Return value:</h3>
0 success 1 on failure
</dd>

<dt><a name="threads.thread.join"></a><strong>join</strong>&nbsp;( to )</dt>
<dd> Join or wait on a thread to finish and free its resouces.

<h3>Parameters</h3>
<ul>
	<li>
	  to: Thread Object
	</li>
</ul>

<h3>Usage:</h3>
<code>
	local ret = thread.join(t);<br/><br/>
	if(ret == 0) then<br/>
		&nbsp;&nbsp;print("success")<br/>
	else<br/>
		&nbsp;&nbsp;print("failed to join thread");<br/>
	end<br/>
</code>

<h3>Return value:</h3>
0 success 1 on failure
</dd>

<dt><a name="threads.thread.cancel"></a><strong>cancel</strong>&nbsp;( to )</dt>
<dd> Signal a thread to terminate and return.

<h3>Parameters</h3>
<ul>
	<li>
	  t: Thread Object
	</li>
</ul>

<h3>Usage:</h3>
<code>
	if(thread.state(parent) == ERROR) then <br/>
		&nbsp;&nbsp;local ret = thread.cancel(child))<br/><br/>
		&nbsp;&nbsp;if( ret == 0 ) then<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;thread.join(child);<br/>
		&nbsp;&nbsp;&nbsp;&nbsp;thread.join(parent);<br/>
		&nbsp;&nbsp;end<br/>
</code>

<h3>Return value:</h3>
0 success 1 on failure
</dd>

<dt><a name="threads.thread.run"></a><strong>run</strong>&nbsp;( to )</dt>
<dd> Get a lua threads running state.

<h3>Parameters</h3>
<ul>
	<li>
	  to: Thread Object
	</li>
</ul>

<h3>Usage:</h3>
<code>
	while(thread.run(t)) do<br/>
	&nbsp;&nbsp;thread.yeild() -- wait for thread "t" to finish<br/>
	end<br/><br/>
	thread.join(t)<br/>
</code>

<h3>Return value:</h3>
true if running, false if complete or errored
</dd>

<dt><a name="threads.thread.state"></a><strong>state</strong>&nbsp;( to )</dt>
<dd> Get a threads execution state. [ WORKING | SUSPENDED | ERROR | OK ]

<h3>Parameters</h3>
<ul>

	<li>
	  to: Thread Object
	</li>
</ul>

<h3>Usage:</h3>
<code>
	while(thread.run(t)) do<br/><br/>
	&nbsp;&nbsp;while(thread.state(t) == WORKING) do<br/>
	&nbsp;&nbsp;&nbsp;&nbsp;some work -- do some work<br/>
	&nbsp;&nbsp;end<br/><br/>
	&nbsp;&nbsp;while(thread.state(t) == SUSPENEDED) do<br/>
				&nbsp;&nbsp;&nbsp;&nbsp;do other work -- do something else, while yielded from main thread<br/>
	&nbsp;&nbsp;end<br/><br/>
	&nbsp;&nbsp;if(thread.state(t) == OK) then return 0 end<br/><br/>
	&nbsp;&nbsp;if(thread.state(t) == ERROR) then return 1 end<br/><br/>
	end<br/>

</code>

<h3>Return value:</h3>
An state enum, representing the thread objects' execution state.
</dd>

<dt><a name="nixio.fs.lstat"></a><strong>sleep</strong>&nbsp;( sec, nsec )</dt>
<dd> Force a thread to sleep for seconds or nano-seconds.

<h3>Parameters</h3>
<ul>
	<li>
	  sec: Integer value representing seconds to sleep
	</li>
	<li>
	  nsec: Integer value representing nano seconds to sleep
	</li>
</ul>

<h3>Usage:</h3>


<h3>Return value:</h3>
No vaule returned

<h3>See also:</h3>
<ul>
	<li><a href="#nixio.fs.stat">
		stat
	</a>
</ul>
</dd>

<dt><a name="threads.thread.exit"></a><strong>exit</strong>&nbsp;( to )</dt>
<dd> Force a thread to exit without returning.

<h3>Parameters</h3>
<ul>
	<li>
	  to: Thread Object
	</li>
</ul>

<h3>Usage:</h3>


<h3>Return value:</h3>
0 success 1 on failure

<h3>See also:</h3>
<ul>
	<li><a href="#threads.thread.complete">
		thread.complete(t)
	</a>
	<li><a href="threads.thread.cancel">
		thread.cancel
	</a>
</ul>
</dd>
</dl>


</div> <!-- id="content" -->

</div> <!-- id="main" -->

<div id="about">
	<p><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0!" height="31" width="88" /></a></p>
</div> <!-- id="about" -->

</div> <!-- id="container" -->
</body>
</html>